# [random face sampling]
plot_cfit<- function(mu_hat, rnum_pixel, cnum_pixel, num_pic){
  pixels_gathered = mu_hat %>%
    mutate(instance = row_number()) %>%
    gather(pixel, value, -instance) %>%
    tidyr::extract(pixel, "pixel", "(\\d+)", convert = TRUE) %>%
    mutate(pixel = pixel - 1,
           x = pixel %% (rnum_pixel*cnum_pixel)%% rnum_pixel,
           y = cnum_pixel - pixel %% (rnum_pixel*cnum_pixel)%/% rnum_pixel,
           rgb_groups = factor(pixel %/% (rnum_pixel * rnum_pixel)))
  pixels_gathered = pixels_gathered%>%group_by(instance)%>%mutate(value = (value-mean(value))/sd(value))
  if (length(unique(pixels_gathered$rgb_groups)) ==1){
    pixels_gathered %>%
      filter(instance <= num_pic) %>%
      ggplot(aes(x, y)) + geom_raster(aes(fill= value))+
      facet_wrap(~ instance) + scale_fill_gradient(low="black",high="white")
  }else{
    pixels_gathered$rgb_groups = factor(pixels_gathered$rgb_groups, labels = c("R", "G", "B"))
    pixels_gathered =  pixels_gathered %>%pivot_wider(id_cols = c(instance, x, y, pixel, rgb_groups),
                                                      names_from = rgb_groups, values_from = value)%>%
      group_by(instance, x,y) %>%mutate(R = mean(R, na.rm = TRUE),
                                        G= mean(G, na.rm = TRUE),
                                        B = mean(B, na.rm = TRUE))%>%ungroup() %>%select(-pixel)%>%distinct()
    pixels_gathered %>%
      filter(instance <= num_pic) %>%
      ggplot(aes(x, y)) + geom_raster(aes(fill= rgb(R/255, G/255, B/255)))+
      scale_fill_identity()+ facet_wrap(~ instance)

  }
}
sample.block <- function (chunk.size, pix_num) {
  start = pix_num * (1:chunk.size) +  sample((1+chunk.size):(pix_num - chunk.size), 1) + sample((pix_num *5):(pix_num* 10), 1)
  end = start + chunk.size
  crop_idx = c()
  for(i in 1:chunk.size){crop_idx = c(crop_idx, start[i]:end[i])}
  return(crop_idx)
}
mask.picture <- function(picture, mask_idx, assign_value = 0){
  picture[mask_idx] = assign_value
  return(picture)
}

# [restore the faces]
ridge_coef <- function(X_vec, weight_vec, Vt, factor_family){
  d = dim(Vt)[1]
  sd_scalar = sqrt(var(X_vec)*(d-1)/d)
  pen_result <- glmnet(x = Vt, y= X_vec, family = factor_family, alpha = 0, lambda=1, weights = weight_vec,
                       intercept = FALSE, standardize = FALSE, thresh= 1e-10,
                       type.logistic = c("Newton"))
  as.vector(coef(pen_result, s = sd_scalar * 1/d, exact = TRUE, x = Vt, y = X_vec,
                 family = factor_family,
                 weights = weight_vec))[-1]
}
